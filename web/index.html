<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>Cesium Bounding Box to FastAPI</title>

    <!--CESIUM-->
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.105/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.105/Build/Cesium/Widgets/widgets.css" rel="stylesheet">

    <!--BOOTSTRAP-->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.6/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-4Q6Gf2aSP4eDXB8Miphtr37CMZZQ5oXLH2yaXMJ2w8e2ZtHTl7GptT4jmndRuHDT" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.6/dist/js/bootstrap.bundle.min.js" integrity="sha384-j1CDi7MgGQ12Z7Qab0qlWQ/Qqz24Gc6BM0thvEMVjHnfYGF0rmFCozFSxQBxwHKO" crossorigin="anonymous"></script>
    <!-- Bootstrap Icons -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">

    <link rel="stylesheet" href="styles/styles.css"></script>

</head>

<body>
    <div id="toolbar">
        <p>Haz clic en el mapa para iniciar el área, y otro clic para terminar.</p>
        <button onclick="sendToBackend()" id="sendBtn" disabled>Enviar coordenadas</button>
        <button onclick="runSimulationWindows()" id="simBtn" disabled>Iniciar Simulación</button>
        <button onclick="runSimulationTraci()" id="simTraciBtn" disabled>Iniciar Simulación Traci</button>
        <button onclick="runSimulationLinux()" id="simLinuxBtn" disabled>Iniciar Simulación Linux</button>
        <button onclick="runSimulationWebsocket()" id="simWebsocketBtn" disabled>Iniciar Simulación Websocket</button>

        <div id="loading" style="display:none; color:yellow;">Generando mapa y simulando tráfico...</div>
    </div>
    <div id="cesiumContainer"></div>

    <div id="spinnerOverlay" class="spinner-overlay">
        <div class="spinner"></div>
    </div>  

    <script>
        // Reemplaza con tu token de Cesium Ion
        Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI3YWQ3ZWY4ZS03NzBjLTRjNzktYTYyNy0zMTRkYmE1NmE1NDciLCJpZCI6MjgwODk3LCJpYXQiOjE3NDEwNzIzMzl9.rpQ6pVt0APCbZ_zhTJkhquCVXwmMo3unuk4ZafCea-k';

        const viewer = new Cesium.Viewer('cesiumContainer');
        let handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);

        let firstPoint = null;
        let rectangleEntity = null;
        let bounds = null;

        viewer.camera.flyTo({
            destination: Cesium.Cartesian3.fromDegrees(-1.872093,42.912304, 3000),
            duration: 0
        });

        let vehicleEntities = {};

        const roadStyles = {
            'highway.motorway': { color: Cesium.Color.BLUE, width: 4 },
            'highway.primary': { color: Cesium.Color.GREEN, width: 4 },
            'highway.secondary': { color: Cesium.Color.YELLOW, width: 4 },
            'highway.tertiary': { color: Cesium.Color.PURPLE, width: 4 },
            'highway.trunk': { color: Cesium.Color.ORANGE, width: 4 },
            'highway.residential': { color: Cesium.Color.WHITE, width: 4 },
            'default': { color: Cesium.Color.GRAY, width: 4 }
        };

        const velocityStyles = {
            '120': { color: Cesium.Color.BLUE, width: 4 },
            '100': { color: Cesium.Color.GREEN, width: 4 },
            '80': { color: Cesium.Color.YELLOW, width: 4 },
            '60': { color: Cesium.Color.PURPLE, width: 4 },
            '40': { color: Cesium.Color.ORANGE, width: 4 },
            '20': { color: Cesium.Color.WHITE, width: 4 },
            'default': { color: Cesium.Color.GRAY, width: 4 }
        };

        function sleep(milliseconds) {
            const date = Date.now();
            let currentDate = null;
            do {
                currentDate = Date.now();
            } while (currentDate - date < milliseconds);
        }

        function mostrarSpinner(){
            document.getElementById('spinnerOverlay').style.display = 'block';
        }

        function ocultarSpinner(){
            document.getElementById('spinnerOverlay').style.display = 'none';
        }

        function getVelocityStyle(velocity) {

            if (velocity>119) {
                return Cesium.Color.BLUE;
            } else if (velocity>101 && velocity<=119) {
                return Cesium.Color.GREEN;
            } else if (velocity>80 && velocity<=101) {
                return Cesium.Color.YELLOW;
            } else if (velocity>60 && velocity<=80) {
                return Cesium.Color.PURPLE;
            } else if (velocity>40 && velocity<=60) {
                return Cesium.Color.ORANGE;
            } else if (velocity>20 && velocity<=40) {
                return Cesium.Color.WHITE;
            } else {
                return Cesium.Color.GRAY;
            }
        }

        function createPropertiesPanel(properties) {
    
            let descrip = `<table class="tablePorperties">`;
            for (const [key, value] of Object.entries(properties)) {
            if (key === 'enlace'|| key === 'url' || key === 'link' || key === 'source') {
                // Si el valor es un enlace, lo formateamos como un enlace HTML
                descrip = descrip + `<tr class="trproper">
                                        <td>Enlace</td>
                                        <td class="tdproper">
                                        <a href="${value}" target="_blank">Ir a Catastro</a>
                                        </td>
                                    </tr>`;
            }
            else{
                descrip = descrip + `<tr class="trproper">
                                        <td class="tdproper">${key}</td>
                                        <td class="tdproper"> ${value}</td>
                                    </tr>`;
            }
            
            }
            descrip = descrip + '</table>';
            return descrip;
        }

        handler.setInputAction(function (click) {
        const cartesian = viewer.camera.pickEllipsoid(click.position, viewer.scene.globe.ellipsoid);

        if (!cartesian) return;

        if (!firstPoint) {
            // Primer clic: iniciamos el punto
            firstPoint = Cesium.Cartographic.fromCartesian(cartesian);
            console.log("Primer punto fijado");
        } else {
            // Segundo clic: finalizamos y calculamos el bounding box
            const secondPoint = Cesium.Cartographic.fromCartesian(cartesian);

            bounds = {
                west: Math.min(firstPoint.longitude, secondPoint.longitude),
                south: Math.min(firstPoint.latitude, secondPoint.latitude),
                east: Math.max(firstPoint.longitude, secondPoint.longitude),
                north: Math.max(firstPoint.latitude, secondPoint.latitude)
            };

            // Dibujar el rectángulo en el mapa
            if (rectangleEntity) viewer.entities.remove(rectangleEntity);

            rectangleEntity = viewer.entities.add({
                rectangle: {
                    coordinates: Cesium.Rectangle.fromRadians(bounds.west, bounds.south, bounds.east, bounds.north),
                    material: Cesium.Color.CYAN.withAlpha(0.4),
                    outline: true,
                    outlineColor: Cesium.Color.CYAN
                }
            });

            document.getElementById('sendBtn').disabled = false;
            document.getElementById('simBtn').disabled = false;
            document.getElementById('simTraciBtn').disabled = false;  
            document.getElementById('simLinuxBtn').disabled = false;  
            document.getElementById('simWebsocketBtn').disabled = false;  
            firstPoint = null; // Reiniciar para una nueva selección
        }
    }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);

        function crearLineString(datosLineString,altura=0) {
            const coordenadas = datosLineString.geometry.coordinates; 
            const posiciones = coordenadas.map(coord => {
            const [lon, lat] = coord;
            return Cesium.Cartesian3.fromDegrees(lon, lat, 0);
            });

            const rawType = datosLineString.properties.velocidad_max ? datosLineString.properties.velocidad_max : 'default';
            const style = roadStyles[datosLineString.properties.velocidad_max] || roadStyles['default'];
            
            const velocityStyle = getVelocityStyle(datosLineString.properties.velocidad_max);
            
            const description = `
                <table class="cesium-infoBox-defaultTable">
                    <tr><th>Tipo</th><td>${rawType}</td></tr>
                    <tr><th>Velocidad Máx</th><td>${datosLineString.properties.velocidad_max} km/h</td></tr>
                    <tr><th>ID Edge</th><td>${datosLineString.properties.id}</td></tr>
                </table>
            `;

            viewer.entities.add({
            description: createPropertiesPanel(datosLineString.properties),
            polyline: {
                positions: posiciones,
                material : velocityStyle,
                width: 3,
                clampToGround: true // Para que la línea se ajuste al terreno
            }
            });
        }

        async function sendToBackend() {
            if (!bounds) return;
            viewer.entities.remove(rectangleEntity);
            const payload = {
                west: Cesium.Math.toDegrees(bounds.west),
                south: Cesium.Math.toDegrees(bounds.south),
                east: Cesium.Math.toDegrees(bounds.east),
                north: Cesium.Math.toDegrees(bounds.north),
                // road_types: ["motorway", "motorway_link", "primary", "secondary", "tertiary", "residential", "unclassified", "living_street", "service", "footway", "cycleway", "steps", "path", "track", "bridleway", "corridor", "ferry", "construction", "proposed", "raceway", "platform", "elevator", "escalator", "moving_walkway", "transit", "subway", "tram", "light_rail", "rail", "monorail"]    
                road_types: ["motorway", "motorway_link", "primary", "secondary", "tertiary", "residential", "living_street","trunk","trunk_link", "primary_link", "secondary_link", "tertiary_link","service"]    
            };

            try {
                mostrarSpinner()
                const response = await fetch('http://localhost:8000/get-roads', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const dataSource = await response.json();

                if (!Array.isArray(dataSource)){
                    entidades = dataSource.features;  
                }
                else {
                    entidades = dataSource[0].features;
                }

                if (!entidades ) {
                    console.warn("No se encontraron entidades en el GeoJSON."); 
                    return;
                }

                for (let i = 0; i < entidades.length; i++) {
                    crearLineString(entidades[i]);
                }
              
                ocultarSpinner()

            } catch (error) {
                ocultarSpinner()
                console.error("Error:", error);
            } finally {
                ocultarSpinner();
            }
        }

        async function startSimulation() {
            if (!bounds) return;
            
            // Ocultar carreteras y mostrar botón de carga
            document.getElementById('loading').style.display = 'block';

            mostrarSpinner();

            const payload = {
                west: Cesium.Math.toDegrees(bounds.west),
                south: Cesium.Math.toDegrees(bounds.south),
                east: Cesium.Math.toDegrees(bounds.east),
                north: Cesium.Math.toDegrees(bounds.north)
            };

            try {
                // 1. Pedir el mapa a Overpass
                const mapResponse = await fetch('http://localhost:8000/get-roads', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const geojsonData = await mapResponse.json();

                // Dibujar mapa base
                const dataSource = await Cesium.GeoJsonDataSource.load(geojsonData);
                viewer.dataSources.add(dataSource);
                // ... (código de estilos de carreteras) ...

                // 2. Pedir la simulación a SUMO
                const simResponse = await fetch('http://localhost:8000/simulate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const simulationData = await simResponse.json();

                // 3. Dibujar vehículos
                const vehicleDataSource = new Cesium.CustomDataSource('Vehicles');
                viewer.dataSources.add(vehicleDataSource);

                // Crear una entidad base para los coches (luego clonaremos)
                const carEntity = vehicleDataSource.entities.add({
                    position: Cesium.Cartesian3.fromDegrees(0, 0),
                    model: {
                        uri: 'models/car.glb', // Asegúrate de tener este modelo en tu carpeta web
                        minimumPixelSize: 16,
                        maximumScale: 20
                    },
                    orientation: new Cesium.CallbackProperty(() => {
                        return Cesium.Matrix4.IDENTITY;
                    }, false)
                });

                // Array para guardar las entidades clonadas
                const carInstances = [];

                // Crear instancias para cada coche
                simulationData.vehicles[0].forEach(v => {
                    const instance = new Cesium.ModelInstance({
                        model: carEntity._model, // Usar el mismo modelo
                        id: v.id,
                        position: Cesium.Cartesian3.fromDegrees(v.lon, v.lat),
                        orientation: Cesium.Transforms.headingPitchRollQuaternion(
                            Cesium.HeadingPitchRoll.fromDegrees(0, 0, v.angle),
                            Cesium.HeadingPitchRollStructure.HEADING_PITCH_ROLL
                        )
                    });
                    carInstances.push(instance);
                });

                // Crear un ModelGraphics para renderizar todas las instancias
                vehicleDataSource.entities.add({
                    model: {
                        instances: carInstances,
                        minimumPixelSize: 16,
                        maximumScale: 20
                    }
                });

                // Ocultar la entidad base
                vehicleDataSource.entities.remove(carEntity);

                // 4. Animación
                let currentStep = 0;
                viewer.clock.shouldAnimate = true;
                viewer.clock.multiplier = 1; // Velocidad de la animación

                viewer.clock.onTick.addEventListener((clock) => {
                    if (currentStep < simulationData.vehicles.length) {
                        const vehicles = simulationData.vehicles[currentStep];
                        
                        vehicles.forEach((v, index) => {
                            const instance = carInstances[index];
                            if (instance) {
                                instance.position = Cesium.Cartesian3.fromDegrees(v.lon, v.lat);
                                instance.orientation = Cesium.Transforms.headingPitchRollQuaternion(
                                    Cesium.HeadingPitchRoll.fromDegrees(0, 0, v.angle),
                                    Cesium.HeadingPitchRollStructure.HEADING_PITCH_ROLL
                                );
                            }
                        });
                        
                        currentStep++;
                    } else {
                        viewer.clock.shouldAnimate = false;
                    }
                });

                viewer.zoomTo(dataSource);

                ocultarSpinner();

            } catch (error) {
                ocultarSpinner();
                alert("Error:", error);
                console.error("Error:", error);
            } finally {
                ocultarSpinner();
                document.getElementById('loading').style.display = 'none';
            }
        }
    
        async function runSimulationWindows() {
            if (!bounds) return;
            viewer.entities.remove(rectangleEntity);
            const payload = {
                west: Cesium.Math.toDegrees(bounds.west),
                south: Cesium.Math.toDegrees(bounds.south),
                east: Cesium.Math.toDegrees(bounds.east),
                north: Cesium.Math.toDegrees(bounds.north),
                // road_types: ["motorway", "motorway_link", "primary", "secondary", "tertiary", "residential", "unclassified", "living_street", "service", "footway", "cycleway", "steps", "path", "track", "bridleway", "corridor", "ferry", "construction", "proposed", "raceway", "platform", "elevator", "escalator", "moving_walkway", "transit", "subway", "tram", "light_rail", "rail", "monorail"]    
                road_types: ["motorway", "motorway_link", "primary", "secondary", "tertiary", "residential", "living_street"]    
            };

            try {
                mostrarSpinner()
                const response = await fetch('http://localhost:8000/simulate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const data = await response.json();

                const startTime = Cesium.JulianDate.now();
                
                // Diccionario para guardar las entidades de los coches
                let vehicleEntities = {};

                data.forEach(frame => {
                    const time = Cesium.JulianDate.addSeconds(startTime, frame.step, new Cesium.JulianDate());
                    
                    frame.vehicles.forEach(veh => {
                        if (!vehicleEntities[veh.id]) {
                            // Si el coche no existe, lo creamos
                            vehicleEntities[veh.id] = viewer.entities.add({
                                id: veh.id,
                                position: new Cesium.SampledPositionProperty(),
                                point: { pixelSize: 10, color: Cesium.Color.YELLOW },
                                label: { text: veh.id, font: '10pt sans-serif', pixelOffset: new Cesium.Cartesian2(0, -15) }
                            });
                        }
                        
                        // Añadimos la posición en este paso de tiempo
                        const position = Cesium.Cartesian3.fromDegrees(veh.lon, veh.lat);
                        vehicleEntities[veh.id].position.addSample(time, position);
                    });
                });
            }
            catch (error) {
                console.error("Error:", error);
            }
            finally {
                ocultarSpinner();
                document.getElementById('loading').style.display = 'none';
            }
        }

        async function runSimulationLinux() {
            if (!bounds) return;
            viewer.entities.remove(rectangleEntity);
            const payload = {
                west: Cesium.Math.toDegrees(bounds.west),
                south: Cesium.Math.toDegrees(bounds.south),
                east: Cesium.Math.toDegrees(bounds.east),
                north: Cesium.Math.toDegrees(bounds.north),
                // road_types: ["motorway", "motorway_link", "primary", "secondary", "tertiary", "residential", "unclassified", "living_street", "service", "footway", "cycleway", "steps", "path", "track", "bridleway", "corridor", "ferry", "construction", "proposed", "raceway", "platform", "elevator", "escalator", "moving_walkway", "transit", "subway", "tram", "light_rail", "rail", "monorail"]    
                road_types: ["motorway", "motorway_link", "primary", "secondary", "tertiary", "residential", "living_street"]    
            };

            try {
                mostrarSpinner()
                const response = await fetch('http://localhost:8000/simularLinux', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const data = await response.json();

                const startTime = Cesium.JulianDate.now();
                
                // Diccionario para guardar las entidades de los coches
                let vehicleEntities = {};

                data.forEach(frame => {
                    const time = Cesium.JulianDate.addSeconds(startTime, frame.step, new Cesium.JulianDate());
                    
                    frame.vehicles.forEach(veh => {
                        if (!vehicleEntities[veh.id]) {
                            // Si el coche no existe, lo creamos
                            vehicleEntities[veh.id] = viewer.entities.add({
                                id: veh.id,
                                position: new Cesium.SampledPositionProperty(),
                                point: { pixelSize: 10, color: Cesium.Color.YELLOW },
                                label: { text: veh.id, font: '10pt sans-serif', pixelOffset: new Cesium.Cartesian2(0, -15) }
                            });
                        }
                        
                        // Añadimos la posición en este paso de tiempo
                        const position = Cesium.Cartesian3.fromDegrees(veh.lon, veh.lat);
                        vehicleEntities[veh.id].position.addSample(time, position);
                    });
                });
            }
            catch (error) {
                console.error("Error:", error);
            }
            finally {
                ocultarSpinner();
                document.getElementById('loading').style.display = 'none';
            }
        }

        async function runSimulationTraci() {
            if (!bounds) return;
            viewer.entities.remove(rectangleEntity);
            const payload = {
                west: Cesium.Math.toDegrees(bounds.west),
                south: Cesium.Math.toDegrees(bounds.south),
                east: Cesium.Math.toDegrees(bounds.east),
                north: Cesium.Math.toDegrees(bounds.north),
                // road_types: ["motorway", "motorway_link", "primary", "secondary", "tertiary", "residential", "unclassified", "living_street", "service", "footway", "cycleway", "steps", "path", "track", "bridleway", "corridor", "ferry", "construction", "proposed", "raceway", "platform", "elevator", "escalator", "moving_walkway", "transit", "subway", "tram", "light_rail", "rail", "monorail"]    
                road_types: ["motorway", "motorway_link", "primary", "secondary", "tertiary", "residential", "living_street","trunk","trunk_link", "primary_link", "secondary_link", "tertiary_link","service"]    
                
            };
            try {
                mostrarSpinner();
                const response = await fetch('http://localhost:8000/run-simulation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const data = await response.json();
                console.log('Simulación completada:', data);


                const startTime = Cesium.JulianDate.now();
                
                // Diccionario para guardar las entidades de los coches
                vehicleEntities = {};
                datosVehiculos = data.data.features;
                console.log('Datos de vehículos:', datosVehiculos);

                ocultarSpinner();
                i=0;
                datosVehiculos.forEach(veh => {
                    setTimeout(() => {
                        animarVehiculos(veh);
                    }, 3000);
                });
                
                
            } catch (error) {
                ocultarSpinner();
                console.error('Error:', error);
            }
            finally {
                ocultarSpinner();
                console.log('Simulación completada');
                document.getElementById('simTraciBtn').disabled = false;
            }
        }

        function animarVehiculos(veh){
            const coordenadas = veh.geometry.coordinates; 
            if (!vehicleEntities[veh.properties.id]) {
                // Si el coche no existe, lo creamos
                vehicleEntities[veh.properties.id] = viewer.entities.add({
                    id: veh.properties.id,
                    position: Cesium.Cartesian3.fromDegrees(coordenadas[0], coordenadas[1]),
                    point: { 
                        id: veh.properties.id,
                        pixelSize: 15, 
                        color: Cesium.Color.RED ,clampToGround: true,
                        heightReference: Cesium.HeightReference.RELATIVE_TO_GROUND, // Úsalo si el punto está en terreno
                        disableDepthTestDistance: Number.POSITIVE_INFINITY 
                    }
                });
            }
            else {
                // Añadimos la posición en este paso de tiempo
                const position = Cesium.Cartesian3.fromDegrees(coordenadas[0], coordenadas[1]);
                viewer.entities.getById(veh.properties.id).position = position;
            }
        }   

        
    
        async function runSimulationWebsocket() {
            if (!bounds) return;
            // Eliminar el rectángulo de la selección
            viewer.entities.remove(rectangleEntity);

            const payload = {
                west: Cesium.Math.toDegrees(bounds.west),
                south: Cesium.Math.toDegrees(bounds.south),
                east: Cesium.Math.toDegrees(bounds.east),
                north: Cesium.Math.toDegrees(bounds.north),
                // road_types: ["motorway", "motorway_link", "primary", "secondary", "tertiary", "residential", "unclassified", "living_street", "service", "footway", "cycleway", "steps", "path", "track", "bridleway", "corridor", "ferry", "construction", "proposed", "raceway", "platform", "elevator", "escalator", "moving_walkway", "transit", "subway", "tram", "light_rail", "rail", "monorail"]    
                road_types: ["motorway", "motorway_link", "primary", "secondary", "tertiary", "residential", "living_street","trunk","trunk_link", "primary_link", "secondary_link", "tertiary_link","service"]    
                
            };

            const socket = new WebSocket('ws://localhost:8000/ws/simulation?bbox='+JSON.stringify(payload));
            const vehicles = {}; // Diccionario para rastrear entidades

            socket.onopen = () => {
                console.log('Conectado al servidor');
            };
    
            socket.onmessage = function(event) {
                const data = JSON.parse(event.data);
                console.log('Datos de vehículos:', data);

                if (!vehicles[veh.properties.id]) {
                    // Crear el vehículo si no existe
                    vehicles[veh.properties.id] = viewer.entities.add({
                        id: veh.properties.id,
                        position: position,
                        // Orientación basada en el ángulo de SUMO
                        orientation: Cesium.Transforms.headingPitchRollQuaternion(
                            position,
                            new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(veh.angle), 0, 0)
                        ),
                        model: {
                            uri: 'ruta/a/tu/modelo_coche.glb', // Puedes usar un punto si no tienes modelo
                            minimumPixelSize: 64
                        },
                        label: { text: veh.id, pixelOffset: new Cesium.Cartesian2(0, -20) }
                    });
                } else {
                    // Actualizar posición y rotación en tiempo real
                    vehicles[veh.properties.id].position = position;
                    vehicles[veh.properties.id].orientation = Cesium.Transforms.headingPitchRollQuaternion(
                        position,
                        new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(veh.angle), 0, 0)
                    );
                }



            }
                
                // data.vehicles.forEach(veh => {
                //     const position = Cesium.Cartesian3.fromDegrees(veh.lon, veh.lat);
                    
                //     if (!vehicles[veh.properties.id]) {
                //         // Crear el vehículo si no existe
                //         vehicles[veh.properties.id] = viewer.entities.add({
                //             id: veh.properties.id,
                //             position: position,
                //             // Orientación basada en el ángulo de SUMO
                //             orientation: Cesium.Transforms.headingPitchRollQuaternion(
                //                 position,
                //                 new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(veh.angle), 0, 0)
                //             ),
                //             model: {
                //                 uri: 'ruta/a/tu/modelo_coche.glb', // Puedes usar un punto si no tienes modelo
                //                 minimumPixelSize: 64
                //             },
                //             label: { text: veh.id, pixelOffset: new Cesium.Cartesian2(0, -20) }
                //         });
                //     } else {
                //         // Actualizar posición y rotación en tiempo real
                //         vehicles[veh.properties.id].position = position;
                //         vehicles[veh.properties.id].orientation = Cesium.Transforms.headingPitchRollQuaternion(
                //             position,
                //             new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(veh.angle), 0, 0)
                //         );
                //     }
                // });

                // Limpiar vehículos que ya no están en la simulación
                // (Opcional: comparar IDs actuales con los del diccionario)
                // };

        }
    </script>
</body>
    
</html>